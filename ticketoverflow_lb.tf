resource "aws_lb_target_group" "ticketoverflow" {
    name = "ticketoverflow"
    port = 6400
    protocol = "HTTP"
    vpc_id = aws_security_group.ticketoverflow.vpc_id
    target_type = "ip"

    health_check {
        path = "/api/v1/health"
        port = 6400
        protocol = "HTTP"
        healthy_threshold = 2
        unhealthy_threshold = 2
        timeout = 5
        interval = 10
    }
}

resource "aws_lb" "ticketoverflow" {
    name = "ticketoverflow"
    internal = false
    load_balancer_type = "application"
    subnets = data.aws_subnets.private.ids
    security_groups = [aws_security_group.ticketoverflow.id]
}


resource "aws_security_group" "ticketoverflow_target" {
  name        = "ticketoverflow-target"
  description = "ticketoverflow Target Security Group"

  ingress {
    from_port       = 6400
    to_port         = 6450
    protocol        = "tcp"
    security_groups = [aws_security_group.ticketoverflow.id]
  }

    ingress {
    from_port = 6379
    to_port = 6379
    protocol = "tcp"
    }

    egress {
        from_port = 6379
        to_port = 6379
        protocol = "tcp"
        cidr_blocks = ["0.0.0.0/0"]
    }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

}

resource "aws_security_group" "ticketoverflow" {
    name = "ticketoverflow"
    description = "ticketoverflow Security Group"
    ingress {
        from_port = 80
        to_port = 80
        protocol = "tcp"
        cidr_blocks = ["0.0.0.0/0"]
    }
    egress {
        from_port = 0
        to_port = 0
        protocol = "-1"
        cidr_blocks = ["0.0.0.0/0"]
    }
}


resource "aws_lb_listener" "ticketoverflow" {
    load_balancer_arn = aws_lb.ticketoverflow.arn
    port = "80"
    protocol = "HTTP"
    default_action {
        type = "forward"
        target_group_arn = aws_lb_target_group.ticketoverflow.arn
    }
}


resource "aws_appautoscaling_target" "ticketoverflow" {
    max_capacity = 6
    min_capacity = 1
    resource_id = "service/${aws_ecs_cluster.ticketoverflow.id}/${aws_ecs_service.ticketoverflow.name}"
    scalable_dimension = "ecs:service:DesiredCount"
    service_namespace = "ecs"
}


resource "aws_appautoscaling_policy" "ticketoverflow_network" {
    name               = "ticketoverflow_network"
    policy_type        = "TargetTrackingScaling"
    resource_id        = aws_appautoscaling_target.ticketoverflow.resource_id
    scalable_dimension = aws_appautoscaling_target.ticketoverflow.scalable_dimension
    service_namespace  = aws_appautoscaling_target.ticketoverflow.service_namespace

    target_tracking_scaling_policy_configuration {
        predefined_metric_specification {
            predefined_metric_type = "ALBRequestCountPerTarget"
            #base command generated by chatgpt but modified to meet documentation requirements
            # https://docs.aws.amazon.com/autoscaling/application/APIReference/API_PredefinedMetricSpecification.html
            resource_label = "app/${aws_lb.ticketoverflow.name}/${element(split("/", aws_lb.ticketoverflow.arn), 3)}/targetgroup/${aws_lb_target_group.ticketoverflow.name}/${element(split("/", aws_lb_target_group.ticketoverflow.arn), 2)}"
        }
        target_value       = 40000
        scale_out_cooldown = 120
        scale_in_cooldown  = 120
    }

    depends_on = [aws_ecs_service.ticketoverflow, aws_security_group.ticketoverflow_target]
}



# output "ticketoverflow_lb_name" {
#   value = aws_lb.ticketoverflow.name 
# }

# output "ticketoverflow_lb_arn" {
#   value = aws_lb.ticketoverflow.arn
# }


# output "ticketoverflow_target_name" {
#   value =  aws_lb_target_group.ticketoverflow.arn
# }

# output "ticketoverflow_target_arn_policy" {
#   value = "app/${aws_lb.ticketoverflow.name}/${element(split("/", aws_lb.ticketoverflow.arn), 3)}/targetgroup/${aws_lb_target_group.ticketoverflow.name}/${element(split("/", aws_lb_target_group.ticketoverflow.arn), 2)}"

# }

output "ticketoverflow_api_url" {
  value = aws_lb.ticketoverflow.dns_name

}
